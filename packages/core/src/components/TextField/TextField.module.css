/* ------------------------------------------------------------------ */
/* TextField — Layer 3                                                 */
/* Material Design floating-label input                               */
/* Variants: outlined (default), filled, standard                     */
/* Reference: MUI TextField + minimals.cc                             */
/* ------------------------------------------------------------------ */

/* ---- Size tokens ------------------------------------------------- */
.root {
  --tf-height-sm: 40px;
  --tf-height-md: 56px;
  --tf-fz-sm: 14px;
  --tf-fz-md: 16px;
  --tf-label-fz: 12px;
  --tf-helper-fz: 12px;

  --tf-padding-x-sm: 12px;
  --tf-padding-x-md: 14px;

  /* Working vars — set by data-size */
  --tf-height: var(--tf-height-md);
  --tf-fz: var(--tf-fz-md);
  --tf-padding-x: var(--tf-padding-x-md);
  --tf-radius: 8px;

  /* Color interface */
  --tf-label-color: var(--prismui-text-secondary);
  --tf-bd: var(--prismui-divider);
  --tf-bg: transparent;
  --tf-color: var(--prismui-text-primary);
  --tf-placeholder-color: var(--prismui-text-disabled);
  --tf-helper-color: var(--prismui-text-secondary);
  --tf-section-color: var(--prismui-action-active);

  /* Layout */
  display: inline-flex;
  flex-direction: column;
  position: relative;
  min-width: 0;
  padding: 0;
  margin: 0;
  border: 0;
  vertical-align: top;
  width: 100%;

  &[data-size='sm'] {
    --tf-height: var(--tf-height-sm);
    --tf-fz: var(--tf-fz-sm);
    --tf-padding-x: var(--tf-padding-x-sm);
  }

  /* Focus state — keep label color unchanged (no primary shift) */

  /* Error state */
  &[data-error] {
    --tf-label-color: var(--prismui-error-main);
    --tf-bd: var(--prismui-error-main);
    --tf-helper-color: var(--prismui-error-main);
  }

  /* Disabled state */
  &[data-disabled] {
    --tf-color: var(--prismui-action-disabled);
    --tf-label-color: var(--prismui-action-disabled);
    --tf-helper-color: var(--prismui-action-disabled);
    pointer-events: none;
  }
}

/* ---- Floating label ---------------------------------------------- */
/* Label is INSIDE .wrapper so top:50% is relative to the input area  */
.label {
  display: block;
  font-weight: 400;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  cursor: text;
  -webkit-tap-highlight-color: transparent;
  font-size: var(--tf-fz);
  color: var(--tf-label-color);
  position: absolute;
  left: var(--tf-padding-x);
  top: 0;
  transform: translate(0, calc(var(--tf-height) / 2 - 50%));
  transform-origin: left top;
  z-index: 1;
  max-width: calc(100% - var(--tf-padding-x) * 2);
  transition:
    color 200ms cubic-bezier(0, 0, 0.2, 1),
    transform 200ms cubic-bezier(0, 0, 0.2, 1),
    max-width 200ms cubic-bezier(0, 0, 0.2, 1),
    left 200ms cubic-bezier(0, 0, 0.2, 1);
  pointer-events: none;

  /* With left section, shift label right (padding + icon 20px + gap 8px) */
  .root[data-with-left-section] & {
    left: calc(var(--tf-padding-x) + 20px + 8px);
    max-width: calc(100% - var(--tf-padding-x) * 2 - 20px - 8px);
  }
}

.required {
  color: var(--prismui-error-main);
  margin-inline-start: 2px;
}

/* ---- Shrink state (focused or has value) ------------------------- */

/* outlined: label moves to top edge of border — only vertical motion */
.root[data-variant='outlined'] .label[data-shrink] {
  transform: translate(0, -9px) scale(0.75);
  max-width: calc(133% - 32px);
  pointer-events: auto;
}

/* outlined + left section: shrink moves label back to left edge */
.root[data-variant='outlined'][data-with-left-section] .label[data-shrink] {
  transform: translate(0, -9px) scale(0.75);
  left: var(--tf-padding-x);
}

/* filled: label moves to top inside the filled area */
.root[data-variant='filled'] .label[data-shrink] {
  transform: translate(0, 7px) scale(0.75);
  max-width: calc(133% - var(--tf-padding-x) * 2);
  pointer-events: auto;
}

/* filled + left section: shrink moves label back to padding-x */
.root[data-variant='filled'][data-with-left-section] .label[data-shrink] {
  transform: translate(0, 7px) scale(0.75);
  left: var(--tf-padding-x);
}

/* standard: label moves above the input */
.root[data-variant='standard'] .label[data-shrink] {
  transform: translate(0, -3px) scale(0.75);
  max-width: 133%;
  pointer-events: auto;
}

/* standard + left section: shrink moves label back to left: 0 */
.root[data-variant='standard'][data-with-left-section] .label[data-shrink] {
  transform: translate(0, -3px) scale(0.75);
  left: 0;
}

/* ---- Input wrapper (border/bg container) ------------------------- */
.wrapper {
  position: relative;
  display: flex;
  align-items: center;
  height: var(--tf-height);
  font-size: var(--tf-fz);
  color: var(--tf-color);
  box-sizing: border-box;
  cursor: text;
  width: 100%;
  line-height: 1.5;

  &[data-multiline] {
    height: auto;
    min-height: var(--tf-height);
  }
}

/* ---- Native input ------------------------------------------------ */
.input {
  font: inherit;
  font-size: var(--tf-fz);
  appearance: none;
  letter-spacing: inherit;
  color: currentcolor;
  border: 0;
  box-sizing: content-box;
  background: none;
  margin: 0;
  -webkit-tap-highlight-color: transparent;
  display: block;
  min-width: 0;
  width: 100%;
  height: 100%;
  padding-inline-start: var(--tf-padding-x);
  padding-inline-end: var(--tf-padding-x);
  padding-block-start: 0;
  padding-block-end: 0;
  line-height: var(--tf-height);

  &:focus,
  &:focus-within {
    outline: none;
  }

  &::placeholder {
    color: var(--tf-placeholder-color);
    opacity: 1;
  }

  &:disabled,
  &[data-disabled] {
    cursor: not-allowed;
    color: var(--prismui-action-disabled);
  }

  &[data-pointer] {
    cursor: pointer;
    user-select: none;
    caret-color: transparent;
  }

  /* When label is present and not shrunk, hide placeholder */
  .root[data-has-label]:not([data-shrink]) & {
    &::placeholder {
      color: transparent;
    }
  }

  /* With left section, remove left padding */
  .root[data-with-left-section] & {
    padding-inline-start: 0;
  }

  /* With right section, remove right padding */
  .root[data-with-right-section] & {
    padding-inline-end: 0;
  }

  /* Multiline (textarea) */
  &[data-multiline] {
    height: auto;
    resize: vertical;
    line-height: 1.5;
    padding-block-start: calc((var(--tf-height) - var(--tf-fz) * 1.5) / 2);
    padding-block-end: calc((var(--tf-height) - var(--tf-fz) * 1.5) / 2);
  }
}

/* ---- Section slots ----------------------------------------------- */
.section {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  height: 100%;
  color: var(--tf-section-color);

  &[data-position='left'] {
    margin-inline-start: var(--tf-padding-x);
    margin-inline-end: 8px;
  }

  &[data-position='right'] {
    margin-inline-start: 8px;
    margin-inline-end: var(--tf-padding-x);
  }

  &>svg {
    width: 20px;
    height: 20px;
  }
}

/* ---- Helper text / Error ----------------------------------------- */
.helperText {
  color: var(--tf-helper-color);
  font-weight: 400;
  font-size: var(--tf-helper-fz);
  line-height: 1.5;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 4px;
  margin: 3px 14px 0 14px;
}

/* ================================================================== */
/* OUTLINED NOTCH — fieldset + legend (MUI approach)                   */
/* The <fieldset> provides the border. The <legend> (visibility:hidden)*/
/* creates the notch gap around the floating label.                    */
/* ================================================================== */
.notch {
  position: absolute;
  inset: -5px 0 0;
  margin: 0;
  padding: 0 8px;
  pointer-events: none;
  border-radius: var(--tf-radius);
  border: 1px solid var(--tf-bd);
  overflow: hidden;
  min-width: 0;
  transition:
    border-color 150ms cubic-bezier(0.4, 0, 0.2, 1),
    border-width 100ms cubic-bezier(0.4, 0, 0.2, 1);

  /* Hover: darken border */
  .wrapper:hover:where(:not([data-disabled])) & {
    border-color: var(--prismui-text-primary);
  }

  /* Focus: thicken border */
  .root:where(:focus-within):where(:not([data-disabled])) & {
    border-width: 2px;
    border-color: var(--prismui-text-primary);
  }

  /* Error state */
  .root[data-error] & {
    border-color: var(--prismui-error-main);
  }

  .root[data-error]:where(:focus-within) & {
    border-color: var(--prismui-error-main);
  }

  /* Disabled */
  .root[data-disabled] & {
    border-color: var(--prismui-action-disabledBackground);
  }
}

.notchLegend {
  float: unset;
  width: auto;
  overflow: hidden;
  display: block;
  padding: 0;
  height: 11px;
  font-size: 0.75em;
  visibility: hidden;
  max-width: 0.01px;
  transition: max-width 50ms cubic-bezier(0, 0, 0.2, 1) 0ms;
  white-space: nowrap;

  &>span {
    padding-inline-start: 5px;
    padding-inline-end: 5px;
    display: inline-block;
    opacity: 0;
    visibility: visible;
  }

  /* When shrunk, expand the legend to create the notch gap */
  &[data-shrink] {
    max-width: 100%;
    transition: max-width 100ms cubic-bezier(0, 0, 0.2, 1) 50ms;
  }
}

/* Hidden legend content (when label is not shrunk) */
.notchLegendHidden {
  display: inline-block;
  visibility: hidden;
  padding-inline-start: 5px;
  padding-inline-end: 5px;
}

/* ================================================================== */
/* VARIANT: outlined                                                   */
/* ================================================================== */
.root[data-variant='outlined'] {

  /* Outlined input: vertically centered */
  & .input {
    padding-block-start: 0;
    padding-block-end: 0;
  }
}

/* ================================================================== */
/* VARIANT: filled                                                     */
/* ================================================================== */
.root[data-variant='filled'] {
  & .wrapper {
    background-color: rgba(0, 0, 0, 0.06);
    border-radius: var(--tf-radius) var(--tf-radius) 0 0;
    transition: background-color 200ms cubic-bezier(0.4, 0, 0.2, 1);

    &:hover:where(:not([data-disabled])) {
      background-color: rgba(0, 0, 0, 0.09);
    }

    /* Static underline via ::before */
    &::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      border-bottom: 1px solid var(--tf-bd);
      transition:
        border-bottom-color 150ms cubic-bezier(0.4, 0, 0.2, 1);
    }

    &:hover:where(:not([data-disabled]))::before {
      border-bottom-width: 2px;
      border-bottom-color: var(--prismui-text-primary);
    }

    /* Animated focus underline via ::after */
    &::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      border-bottom: 2px solid var(--prismui-text-primary);
      transform: scaleX(0);
      transform-origin: center;
    }

    .root:where(:focus-within):where(:not([data-disabled])) &::after {
      transform: scaleX(1);
      transition: transform 200ms cubic-bezier(0, 0, 0.2, 1);
    }

    .root:where(:not(:focus-within)):where(:not([data-disabled])) &::after {
      transform: scaleX(0);
      transition: transform 200ms cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Error underline */
    .root[data-error] &::after {
      border-bottom-color: var(--prismui-error-main);
      transform: scaleX(1);
    }

    /* Disabled */
    .root[data-disabled] & {
      background-color: rgba(0, 0, 0, 0.04);
    }

    .root[data-disabled] &::before {
      border-bottom-style: dotted;
    }
  }

  /* Filled: label is inside the filled area, input pushed down for label space */
  & .label {
    /* Center vertically in the filled area */
    transform: translate(0, calc(var(--tf-height) / 2 - 50%));
  }

  & .input {
    padding-block-start: 21px;
    padding-block-end: 4px;
    line-height: 1.5;
    height: auto;
  }
}

/* ================================================================== */
/* VARIANT: standard                                                   */
/* ================================================================== */
.root[data-variant='standard'] {
  & .wrapper {

    /* Static underline via ::before */
    &::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      border-bottom: 1px solid var(--tf-bd);
      transition:
        border-bottom-color 150ms cubic-bezier(0.4, 0, 0.2, 1);
    }

    &:hover:where(:not([data-disabled]))::before {
      border-bottom-width: 2px;
      border-bottom-color: var(--prismui-text-primary);
    }

    /* Animated focus underline via ::after */
    &::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      border-bottom: 2px solid var(--prismui-text-primary);
      transform: scaleX(0);
      transform-origin: center;
    }

    .root:where(:focus-within):where(:not([data-disabled])) &::after {
      transform: scaleX(1);
      transition: transform 200ms cubic-bezier(0, 0, 0.2, 1);
    }

    .root:where(:not(:focus-within)):where(:not([data-disabled])) &::after {
      transform: scaleX(0);
      transition: transform 200ms cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Error underline */
    .root[data-error] &::after {
      border-bottom-color: var(--prismui-error-main);
      transform: scaleX(1);
    }

    /* Disabled */
    .root[data-disabled] &::before {
      border-bottom-style: dotted;
    }
  }

  /* Standard: no horizontal padding, input pushed down for label space */
  & .input {
    padding-inline-start: 0;
    padding-inline-end: 0;
    padding-block-start: 20px;
    padding-block-end: 5px;
    line-height: 1.5;
    height: auto;
  }

  /* Standard label: positioned at left: 0 */
  & .label {
    left: 0;
    max-width: 100%;
    transform: translate(0, calc(var(--tf-height) / 2 - 50%));
  }

  /* Standard + left section: label starts after icon */
  &[data-with-left-section] .label {
    left: calc(20px + 8px);
    max-width: calc(100% - 20px - 8px);
  }

  /* Standard + left section + shrink: label goes to left: 0 */
  &[data-with-left-section] .label[data-shrink] {
    left: 0;
  }

  /* Standard sections: no extra margin */
  & .section[data-position='left'] {
    margin-inline-start: 0;
  }

  & .section[data-position='right'] {
    margin-inline-end: 0;
  }
}

/* Standard helper text: no horizontal margin */
.root[data-variant='standard'] .helperText {
  margin-inline-start: 0;
  margin-inline-end: 0;
}